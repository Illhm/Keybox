name: KeyBox Checker

on:
  workflow_dispatch:
    inputs:
      keybox_url:
        description: "URL ke file KeyBox (XML)"
        required: true
        type: string
      revocations_url:
        description: "URL file JSON revocation (opsional)"
        required: false
        type: string

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install cryptography lxml

      - name: Download KeyBox XML
        env:
          KEYBOX_URL: ${{ inputs.keybox_url }}
        run: |
          set -e
          curl -L "$KEYBOX_URL" -o "keybox.xml"
          echo "KeyBox downloaded: keybox.xml (size: $(wc -c < keybox.xml) bytes)"

      - name: Download revocation list (optional)
        if: ${{ inputs.revocations_url }}
        env:
          REVOKE_URL: ${{ inputs.revocations_url }}
        run: |
          curl -L "$REVOKE_URL" -o "revoked.json"
          echo "Revocations downloaded: revoked.json"

      - name: Create checker script
        shell: bash
        run: |
          set -e
          cat > keybox_checker.py <<'PYCODE'
from __future__ import annotations
import argparse, sys, json
from datetime import datetime, timezone
from lxml import etree
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.asymmetric import ec, rsa, padding
from cryptography import x509

def load_revocations(path):
    if not path: return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            d = json.load(f)
        return {s.lower(): d.get("policy", {}).get(s, "REVOKED") for s in d.get("serials", [])}
    except Exception as e:
        print(f"âš ï¸ Error reading revocations: {e}")
        return {}

def load_certs(pems):
    certs = []
    for pem in pems:
        try:
            certs.append(x509.load_pem_x509_certificate(pem))
        except Exception as e:
            print(f"âš ï¸ Failed to load certificate: {e}")
    return certs

def check_private_key(alg, pem):
    try:
        key = load_pem_private_key(pem, password=None)
        if alg == "ecdsa": return isinstance(key, ec.EllipticCurvePrivateKey)
        if alg == "rsa":   return isinstance(key, rsa.RSAPrivateKey)
    except Exception:
        pass
    return False

def algo_name(cert):
    sig = (cert.signature_algorithm_oid._name or "").lower()
    try:
        h = cert.signature_hash_algorithm.name.upper()
    except Exception:
        h = "UNKNOWN"
    if "ecdsa" in sig: return f"ECDSA with {h}"
    if "rsa" in sig or "rsassa" in sig: return f"RSA with {h}"
    return f"{sig} ({h})"

def subject_str(cert):
    parts = []
    for r in cert.subject.rdns:
        for a in r:
            n = a.oid._name or a.oid.dotted_string
            if n.lower() in ("serialnumber", "title"):
                parts.append(f"{n}={a.value}")
    return ", ".join(parts) if parts else cert.subject.rfc4514_string()

def issuer_str(cert):
    parts = []
    for r in cert.issuer.rdns:
        for a in r:
            n = a.oid._name or a.oid.dotted_string
            if n.lower() in ("serialnumber", "title"):
                parts.append(f"{n}={a.value}")
    return ", ".join(parts) if parts else cert.issuer.rfc4514_string()

def verify_chain(certs):
    res = {}
    for i, c in enumerate(certs):
        checks = {"serial": True, "subject": True, "issuer": True, "signature": False, "not_expired": False, "in_chain": True}
        now = datetime.now(timezone.utc)
        try:
            nb = c.not_valid_before.replace(tzinfo=timezone.utc)
            na = c.not_valid_after.replace(tzinfo=timezone.utc)
            checks["not_expired"] = (nb <= now <= na)
        except Exception:
            checks["not_expired"] = False

        issuer = certs[i+1] if i < len(certs)-1 else c
        try:
            pub = issuer.public_key()
            if isinstance(pub, rsa.RSAPublicKey):
                pub.verify(c.signature, c.tbs_certificate_bytes, padding.PKCS1v15(), c.signature_hash_algorithm)
            else:
                pub.verify(c.signature, c.tbs_certificate_bytes, ec.ECDSA(c.signature_hash_algorithm))
            checks["signature"] = (c.issuer == issuer.subject)
        except Exception:
            checks["signature"] = False
        res[i] = checks
    return res

def hex_serial(c): return f"{c.serial_number:x}"
def fmt_dt(dt): return dt.strftime("%d/%b/%Y")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("xml")
    ap.add_argument("--revocations")
    args = ap.parse_args()
    revmap = load_revocations(args.revocations)

    with open(args.xml, "rb") as f:
        xml = f.read()
    root = etree.fromstring(xml)
    kboxes = root.findall(".//Keybox")
    leaked = False
    print(f"ðŸ’¾ File: {args.xml}\n")
    if not kboxes:
        print("ðŸ”´ Tidak ada <Keybox> di XML."); sys.exit(1)

    for kb_i, kb in enumerate(kboxes, start=1):
        keys = kb.findall("./Key")
        for ch_i, key in enumerate(keys, start=1):
            alg = (key.get("algorithm") or "").lower()
            print(f"ðŸ”‘ Key Chain: #{ch_i}")
            priv_node = key.find("./PrivateKey")
            valid_pk = False
            if priv_node is not None and (priv_node.text or "").strip():
                leaked = True
                valid_pk = check_private_key(alg, (priv_node.text or "").strip().encode())
                t = "EC" if alg == "ecdsa" else ("RSA" if alg == "rsa" else "Unknown")
                print(f"{'âœ…' if valid_pk else 'ðŸ”´'} {'Valid' if valid_pk else 'Invalid'} {t} Private Key.")
            else:
                print("âš ï¸ Tanpa Private Key di XML.")

            cert_nodes = key.findall("./CertificateChain/Certificate")
            pems = [(c.text or '').strip().encode() for c in cert_nodes]
            certs = load_certs(pems)
            chain = verify_chain(certs)

            for i, c in enumerate(certs, start=1):
                print(f"\nðŸ” Certificate: #{i}")
                s = hex_serial(c)
                print(f"â„¹ï¸ Serial: {s}.")
                print(f"â„¹ï¸ Subject: {subject_str(c)}.")
                print(f"â„¹ï¸ Issuer: {issuer_str(c)}.")
                print(f"â„¹ï¸ Signature Algorithm: {algo_name(c)}.")
                print(f"â„¹ï¸ Validity (GMT): From: {fmt_dt(c.not_valid_before)} To: {fmt_dt(c.not_valid_after)}.")
                chk = chain[i-1]
                print(f"{'âœ…' if chk['in_chain'] else 'ðŸ”´'} Valid Chain.")
                print(f"{'âœ…' if chk['serial'] else 'ðŸ”´'} Valid Serial.")
                print(f"{'âœ…' if chk['subject'] else 'ðŸ”´'} Valid Subject.")
                print(f"{'âœ…' if chk['issuer'] else 'ðŸ”´'} Valid Issuer.")
                print(f"{'âœ…' if chk['signature'] else 'ðŸ”´'} Valid Signature.")
                print(f"{'âœ…' if chk['not_expired'] else 'ðŸ”´'} Not Expired.")
                if s.lower() in revmap:
                    print(f"ðŸ”´ REVOKED: {revmap[s.lower()]}.")
                else:
                    print("âœ… Not Revoked.")

            strong_ok = (alg == 'ecdsa' and valid_pk and all(v['signature'] and v['not_expired'] for v in chain.values())
                         and not any(hex_serial(c).lower() in revmap for c in certs))
            softban = (alg == 'ecdsa' and valid_pk and any(hex_serial(c).lower() in revmap for c in certs))
            print("\nðŸ”Ž RESULT: ðŸ”Ž\n")
            if strong_ok:
                print(f"âœ… Key Chain #{ch_i} VALID for STRONG integrity.")
            elif softban:
                print(f"âŒ Key Chain #{ch_i} not valid for STRONG integrity.")
                print(f"ðŸŸ¢ Key Chain #{ch_i} VALID SOFTBANNED for DEVICE integrity.")
            else:
                print(f"âŒ Key Chain #{ch_i} INVALID.")
            print("\n" + ("-"*60) + "\n")

    print("ðŸš¨ This KeyBox has been LEAKED." if leaked else "âœ… No private keys embedded. Not flagged as leaked.")
    print("\n[ @KeyBox_Checker ] [ CI v1.1 ]")

if __name__ == "__main__":
    main()
PYCODE

      - name: Run KeyBox Checker
        shell: bash
        run: |
          set -e
          if [ -f revoked.json ]; then
            python keybox_checker.py keybox.xml --revocations revoked.json | tee report.txt
          else
            python keybox_checker.py keybox.xml | tee report.txt
          fi
          {
            echo "### KeyBox Checker Result"
            echo
            echo '```text'
            grep -E "RESULT|LEAKED|VALID" report.txt | tail -n 50
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload report artifact
        uses: actions/upload-artifact@v4
        with:
          name: keybox-report
          path: |
            report.txt
            keybox.xml
            revoked.json
          if-no-files-found: ignore
